//===- ScheduleOptimizer.cpp - Optimize an ISL schedule with Pluto.-----======//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
//
//===----------------------------------------------------------------------===//

#include "polly/Test/ScheduleOptimizer.h"
#include "polly/JSONExporter.h"
#include "polly/Options.h"
#include "polly/Test/OpenSCoPExporter.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
#include <cstdio>
#include <fstream>
#include <osl/scop.h>
#include <string>

using namespace llvm;
using namespace polly;

static cl::opt<std::string> PlutoArguments(
    "polly-pluto-args", cl::desc("Arguments to be passed to pluto optimizer"),
    cl::Hidden, cl::ValueRequired,
    cl::init("--tile --nodiamond-tile --nointratileopt --parallel"),
    cl::cat(PollyCategory));

namespace {

std::string exec(const char *Command) {
  std::array<char, 512> Buffer;
  std::string Result;

  std::unique_ptr<FILE, decltype(&pclose)> Pipe(popen(Command, "r"), pclose);

  if (!Pipe) {
    errs() << "popen() failed!\n";
    return "";
  }

  while (fgets(Buffer.data(), Buffer.size(), Pipe.get()) != nullptr) {
    Result += Buffer.data();
  }

  return Result;
}

std::string extractOpenScopFromString(std::string &Input) {
  size_t Start = Input.find("# [File generated by the OpenScop Library");
  size_t End = Input.find("</OpenScop>");
  End += std::string("</OpenScop>").size();

  return Input.substr(Start, End - Start);
}

void saveToFile(const std::string &Filename, const std::string &Content) {
  std::ofstream Outfile(Filename);
  if (!Outfile)
    llvm_unreachable("Erreur d'ouverture du fichier");
  Outfile << Content;
  Outfile.close();
}
} // namespace

PreservedAnalyses
PlutoScheduleOptimizerPass::run(Scop &S, ScopAnalysisManager &SAM,
                                ScopStandardAnalysisResults &SAR,
                                SPMUpdater &U) {
  errs() << "PlutoScheduleOptimizerPass run on " << S.getName() << "\n";

  std::string FileNameInput = "./" + getFileName(S, "_input", "scop");

  OpenSCoPExportPass::exportOpenScop(S, FileNameInput);

  errs() << "Calling pluto on the file " << FileNameInput << "\n";

  std::string CopyCommand =
      "docker cp " + FileNameInput + " pluto_container:/home/";
  errs() << "CopyCommand: " << CopyCommand << "\n";
  std::system(CopyCommand.c_str());

  std::string RunPlutoCommand =
      "docker exec pluto_container sh -c \"cat /home/" + FileNameInput +
      " | pluto " + PlutoArguments +
      " --readscop "
      "stdin -o "
      "stdout\"";
  errs() << "RunPlutoCommand: " << RunPlutoCommand << "\n";
  auto ResultPluto = exec(RunPlutoCommand.c_str());

  errs() << "Result of pluto:\n" << ResultPluto << "\n";

  std::string NewScopExtracted = extractOpenScopFromString(ResultPluto);

  std::string FileNameOutput = getFileName(S, "_output", "scop");
  saveToFile(FileNameOutput, NewScopExtracted);

  OpenSCoPImportPass::importOpenScop(S, FileNameOutput);

  return PreservedAnalyses::none();
}
